# SPEC.md

# Music Assistant v2 - 개발 계획서

음성 멜로디 분석을 위한 웹 애플리케이션 개발 프로젝트입니다. 오디오 파일을 업로드하여 주파수, 음고, 온셋 데이터를 추출하고 시각화하는 시스템을 단계별로 구축합니다.

## 프로젝트 개요

각 단계(Phase)는 독립적이고 완전한 실행 가능한 결과물을 목표로 합니다.

---

## Phase 1: 핵심 분석 기능 백엔드 API 구축

**목표**: 오디오 파일을 입력받아 주파수, 음고, 온셋 데이터를 JSON 형태로 반환하는 기본적인 백엔드 API를 구축합니다. 프론트엔드 없이도 API의 동작을 독립적으로 테스트할 수 있습니다.

### 백엔드 (Python)

#### 프레임워크 선택
- [x] 경량 웹 프레임워크인 Flask 또는 FastAPI를 사용하여 API 서버를 구축
- [x] FastAPI 선택 (현대적이고 성능이 뛰어나며 자동 API 문서 생성 지원)

#### 핵심 로직 구현
- [x] analyze_vocal_melody 함수를 API의 핵심 로직으로 구현
- [x] 오디오 파일 처리하여 음고(Hz 및 음이름), 온셋 시간(초) 등의 데이터 추출

#### API 엔드포인트 설계
- [x] POST /analyze 엔드포인트 생성
- [x] multipart/form-data 형식으로 오디오 파일(.wav, .mp3) 입력받기
- [x] 분석 완료 시 다음 구조의 JSON 데이터 반환:
  ```json
  {
    "pitch_contour": [
      {"time": 0.01, "frequency": 261.63, "note": "C4"},
      {"time": 0.02, "frequency": 262.10, "note": "C4"}
    ],
    "onsets": [
      {"time": 0.52, "note": "C4", "frequency": 261.50},
      {"time": 1.10, "note": "G4", "frequency": 392.00}
    ],
    "waveform": [...],
    "spectrogram": [...]
  }
  ```

#### 의존성 관리
- [x] requirements.txt 파일 생성
- [x] 라이브러리 버전 명시: fastapi, uvicorn, python-multipart, librosa, numpy, scipy

### 실행 및 테스트
- [x] Python 백엔드 서버를 `uvicorn main:app --reload` 명령어로 실행
- [x] Postman이나 curl로 로컬 /analyze 엔드포인트 테스트
- [x] 오디오 파일 전송 시 예상된 JSON 응답 정상 반환 확인

### 결과물
- [x] 오디오 파일을 분석하고 구조화된 데이터를 반환하는 독립 실행형 Python 백엔드 API

---

## Phase 2: 기본 프론트엔드 연동 및 결과 표시

**목표**: 사용자가 오디오 파일을 업로드하고 백엔드 API로부터 받은 분석 결과를 화면에 텍스트 형태로 확인할 수 있는 최소 기능의 웹 애플리케이션을 구축합니다.

### 백엔드 (Python)
- [x] CORS 설정: Next.js 프론트엔드(다른 포트)로부터의 요청 허용하도록 CORS 미들웨어 설정

### 프론트엔드 (Next.js)

#### 프로젝트 초기 설정
- [x] create-next-app을 사용하여 Next.js 프로젝트 생성

#### UI 컴포넌트 생성
- [x] 파일을 선택할 수 있는 `<input type="file">` 엘리먼트 포함한 업로드 폼 생성
- [x] "분석하기" 버튼 추가

#### API 통신
- [x] fetch API 또는 axios 라이브러리를 사용하여 백엔드 /analyze 엔드포인트로 FormData 객체 전송
- [x] 백엔드로부터 받은 JSON 응답을 React useState로 상태 관리

#### 결과 표시
- [x] 수신된 JSON 데이터를 `<pre>` 태그 등을 사용하여 화면에 출력
- [x] 분석 중임을 알리는 로딩 상태("분석 중...") 표시

### 실행 및 테스트
- [x] 백엔드 서버와 Next.js 개발 서버(`npm run dev`) 동시 실행
- [x] 웹 브라우저에서 프론트엔드 접속하여 오디오 파일 업로드
- [x] 분석 버튼 클릭 시 백엔드로부터 받은 JSON 데이터 화면 표시 확인

### 결과물
- [x] 사용자가 파일을 업로드하고 분석 결과를 텍스트로 확인할 수 있는 기본적인 웹 애플리케이션

---

## Phase 3: 데이터 시각화 기능 구현

**목표**: 백엔드에서 받은 파형, 스펙트로그램, 음고, 온셋 데이터를 사용하여 상호작용 가능한 차트로 시각화합니다.

### 백엔드 (Python)
- [x] 시각화에 적합한 형태로 데이터 가공하여 전달
- [x] 전체 파형 데이터를 시각화에 적합하도록 다운샘플링하는 로직 추가

### 프론트엔드 (Next.js)

#### 차트 라이브러리 설치
- [x] Chart.js (with react-chartjs-2), D3.js, 또는 Plotly.js 데이터 시각화 라이브러리 추가
- [x] Chart.js 선택 (사용이 간편하여 빠른 프로토타이핑에 적합)

#### 시각화 컴포넌트 개발

##### 파형 및 온셋 플롯
- [x] 하나의 차트 위에 파형 데이터를 라인 차트로 그리기
- [x] 탐지된 온셋 시간(onset_times) 위치에 수직선을 겹쳐서 그리기

##### 스펙트로그램 및 음고 플롯
- [x] 스펙트로그램 데이터를 히트맵 또는 이미지 형태로 표시
- [x] 음고(f0) 데이터를 스펙트로그램 위에 라인 차트로 오버레이
- [x] 이중 Y축(dual-axis) 기능을 사용하여 주파수 축과 음고 축 스케일 조정

#### UI 통합
- [x] Phase 2에서 텍스트로 표시하던 부분을 새로 개발한 시각화 컴포넌트로 대체

### 실행 및 테스트
- [x] 오디오 파일 업로드 시 파형, 스펙트로그램, 음고 윤곽선, 온셋 마커가 포함된 차트 정확한 렌더링 확인
- [x] 차트의 축 레이블, 범례 등이 올바르게 표시되는지 검토

### 결과물
- [x] 분석 결과를 직관적인 그래프로 보여주는 동적인 웹 애플리케이션

---

## Phase 4: 사용자 경험 개선 및 프로덕션 준비

**목표**: 애플리케이션의 안정성과 사용성을 높이고, 배포를 위한 기반을 마련합니다.

### 백엔드 (Python)

#### 컨테이너화
- [ ] Docker를 사용하여 Python 애플리케이션 컨테이너화
- [ ] Dockerfile 작성하여 의존성 설치 및 실행 환경 코드화

#### 프로덕션 서버
- [ ] 개발용 서버(uvicorn) 대신 Gunicorn과 같은 WSGI 서버 도입
- [ ] 여러 워커를 통해 동시 요청 처리 가능하도록 설정

#### 오류 처리 및 로깅
- [ ] 유효하지 않은 파일 형식이나 분석 실패 시 명확한 오류 메시지와 HTTP 상태 코드 반환
- [ ] 예외 처리 강화
- [ ] 요청 및 오류에 대한 로그 기록하여 추적 및 디버깅 용이하게 설정

### 프론트엔드 (Next.js)

#### UI/UX 개선
- [ ] 업로드 진행 상태를 보여주는 프로그레스 바 추가
- [ ] 분석 중일 때 스켈레톤 UI나 스피너 표시하여 사용자 피드백 제공
- [ ] 백엔드에서 받은 오류 메시지를 사용자 친화적인 형태로 표시
- [ ] 반응형 디자인 적용하여 다양한 화면 크기에서 UI 깨지지 않도록 설정

#### 상태 관리
- [ ] 복잡해지는 클라이언트 상태를 효율적으로 관리하기 위해 Zustand나 Jotai와 같은 경량 상태 관리 라이브러리 도입 고려

### 실행 및 테스트
- [ ] Docker 컨테이너로 백엔드 실행하고 프론트엔드와 정상적으로 통신 테스트
- [ ] 일부러 잘못된 형식의 파일 업로드하여 오류 처리 로직 동작 확인
- [ ] 서버를 중지시켜 오류 처리 로직 테스트

### 결과물
- [ ] 안정적이고 사용자 친화적이며, 배포 준비가 된 웹 애플리케이션

---

## Phase 5: 비동기 처리 도입 및 확장

**목표**: 용량이 크거나 길이가 긴 오디오 파일 분석 시 타임아웃이 발생하는 문제를 해결하고, 시스템을 수평적으로 확장할 수 있는 아키텍처를 구축합니다.

### 백엔드 (Python)

#### 비동기 작업 큐 도입
- [ ] 오디오 분석과 같이 시간이 오래 걸리는 작업을 비동기적으로 처리하기 위해 Celery와 메시지 브로커(Redis 또는 RabbitMQ) 도입
- [ ] /analyze 엔드포인트는 파일을 받은 즉시 Celery 작업 생성하고, 사용자에게는 작업 ID(task_id) 즉시 반환
- [ ] 분석 작업은 Celery 워커(별도의 프로세스)가 백그라운드에서 수행
- [ ] 완료되면 결과를 데이터베이스나 캐시에 저장

#### 결과 확인 엔드포인트 추가
- [ ] GET /results/{task_id} 엔드포인트 생성
- [ ] 프론트엔드는 이 엔드포인트를 주기적으로 호출(폴링)하여 작업 상태(진행 중, 완료, 실패)와 최종 분석 결과 확인

### 프론트엔드 (Next.js)

#### 폴링 로직 구현
- [ ] 파일 업로드 후 받은 task_id를 사용하여 /results/{task_id} 엔드포인트를 일정 간격(예: 2초마다)으로 호출
- [ ] 작업이 완료될 때까지 로딩 상태 유지하고, 결과를 받으면 시각화 렌더링
- [ ] 작업이 실패하면 오류 메시지 표시

### 실행 및 테스트
- [ ] 수 분 길이의 긴 오디오 파일을 업로드해도 웹 요청이 타임아웃되지 않고 즉시 응답 받는지 확인
- [ ] 프론트엔드가 백그라운드 작업 상태를 올바르게 폴링하고, 작업 완료 후 결과를 정상적으로 표시하는지 테스트

### 결과물
- [ ] 대용량 파일도 안정적으로 처리할 수 있는 확장 가능한 비동기 처리 시스템

---

## 프로젝트 완료 기준

각 Phase별로 모든 체크박스가 완료되면 해당 Phase를 완료한 것으로 간주합니다. 전체 5개 Phase가 모두 완료되면 Music Assistant v2 프로젝트가 완성됩니다.